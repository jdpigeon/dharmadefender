"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var event_target_shim_1 = require("event-target-shim");
var CharacteristicMock = (function (_super) {
    __extends(CharacteristicMock, _super);
    function CharacteristicMock(service) {
        var _this = _super.call(this) || this;
        _this.service = service;
        return _this;
    }
    CharacteristicMock.prototype.startNotifications = function () { };
    CharacteristicMock.prototype.readValue = function () { };
    CharacteristicMock.prototype.writeValue = function () { };
    return CharacteristicMock;
}(event_target_shim_1.EventTarget));
exports.CharacteristicMock = CharacteristicMock;
var PrimaryServiceMock = (function () {
    function PrimaryServiceMock(device) {
        this.device = device;
        this.characteristicMocks = {};
    }
    PrimaryServiceMock.prototype.getCharacteristic = function (characteristic) {
        return Promise.resolve(this.getCharacteristicMock(characteristic));
    };
    PrimaryServiceMock.prototype.getCharacteristicMock = function (characteristic) {
        if (!this.characteristicMocks[characteristic]) {
            this.characteristicMocks[characteristic] = new CharacteristicMock(this);
        }
        return this.characteristicMocks[characteristic];
    };
    return PrimaryServiceMock;
}());
exports.PrimaryServiceMock = PrimaryServiceMock;
var GattMock = (function () {
    function GattMock(device) {
        this.device = device;
        this.device = device;
    }
    GattMock.prototype.connect = function () {
        return Promise.resolve(this);
    };
    GattMock.prototype.getPrimaryService = function (service) {
        return Promise.resolve(this.device.getServiceMock(service));
    };
    return GattMock;
}());
exports.GattMock = GattMock;
var DeviceMock = (function (_super) {
    __extends(DeviceMock, _super);
    function DeviceMock(name, services) {
        var _this = _super.call(this) || this;
        _this.name = name;
        _this.services = services;
        _this.serviceMocks = {};
        _this.gatt = new GattMock(_this);
        return _this;
    }
    DeviceMock.prototype.hasService = function (service) {
        return this.services && this.services.indexOf(service) >= 0;
    };
    DeviceMock.prototype.getServiceMock = function (service) {
        if (!this.serviceMocks[service]) {
            this.serviceMocks[service] = new PrimaryServiceMock(this);
        }
        return this.serviceMocks[service];
    };
    return DeviceMock;
}(event_target_shim_1.EventTarget));
exports.DeviceMock = DeviceMock;
var WebBluetoothMock = (function () {
    function WebBluetoothMock(devices) {
        this.devices = devices;
    }
    WebBluetoothMock.prototype.requestDevice = function (options) {
        for (var _i = 0, _a = this.devices; _i < _a.length; _i++) {
            var device = _a[_i];
            for (var _b = 0, _c = options.filters; _b < _c.length; _b++) {
                var filter = _c[_b];
                if (filter.name && filter.name === device.name) {
                    return Promise.resolve(device);
                }
                if (filter.namePrefix && device.name && device.name.indexOf(filter.namePrefix) === 0) {
                    return Promise.resolve(device);
                }
                if (filter.services) {
                    var found = true;
                    for (var _d = 0, _e = filter.services; _d < _e.length; _d++) {
                        var service = _e[_d];
                        found = found && device.hasService(service);
                    }
                    if (found) {
                        return Promise.resolve(device);
                    }
                }
            }
        }
        return Promise.reject(new Error('User cancelled device chooser'));
    };
    return WebBluetoothMock;
}());
exports.WebBluetoothMock = WebBluetoothMock;
//# sourceMappingURL=web-bluetooth.mock.js.map